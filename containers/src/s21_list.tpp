#include "s21_list.h"

namespace s21 {

// Функция-член set_size_node класса list
// Данная функция обновляет специальный узел `size_node_` следующим образом:
// - Записывает в поле `value_` узла `size_node_` текущее количество элементов в списке (результат вызова size()).
// - Настраивает поля `next_` и `prev_` узла `size_node_`, чтобы они указывали на голову (head_) и хвост (tail_) списка соответственно.
// - Если голова списка (head_) не пуста, то поле `prev_` головы обновляется, чтобы указывать на `size_node_`.
// - Если хвост списка (tail_) не пуст, то поле `next_` хвоста обновляется, чтобы указывать на `size_node_`.

template <typename T>
void list<T>::set_size_node() {
  // Устанавливаем значение количества элементов списка в поле value_ узла size_node_
  size_node_->value_ = size(); 

  // Устанавливаем указатель на голову списка в поле next_ узла size_node_
  size_node_->next_ = head_;

  // Устанавливаем указатель на хвост списка в поле prev_ узла size_node_
  size_node_->prev_ = tail_;

  // Проверяем, существует ли голова списка
  if (head_) {
    // Устанавливаем предыдущий узел головы на size_node_
    head_->prev_ = size_node_;
  }

  // Проверяем, существует ли хвост списка
  if (tail_) {
    // Устанавливаем следующий узел хвоста на size_node_
    tail_->next_ = size_node_;
  }
}


// Функция-член delete_size_node класса list
// Данная функция удаляет специальный узел `size_node_` из памяти.
// Она используется, чтобы освободить ресурсы, занятые узлом `size_node_`,
// когда он больше не нужен.

// Примечание:
// - Перед вызовом этой функции необходимо убедиться, что `size_node_`
//   корректно отсоединён от других узлов списка, если это требуется,
//   чтобы избежать некорректного поведения (например, разыменования удалённого указателя).
// - После удаления указатель `size_node_` должен быть обнулён (например, `size_node_ = nullptr`),
//   чтобы избежать проблем с повторным обращением к нему.

template <typename T>
void list<T>::delete_size_node() {
  // Удаляем узел size_node_, освобождая выделенную для него память
  delete size_node_;
}

// Конструктор класса list
// Этот конструктор инициализирует пустой список, задаёт его начальные параметры,
// создаёт специальный узел `size_node_`, который хранит информацию о размере списка,
// и связывает этот узел с головой и хвостом списка.

template <typename T>
list<T>::list()
    : size_(0),            // Инициализируем размер списка как 0
      head_(nullptr),      // Устанавливаем указатель на голову списка как nullptr (пустой список)
      tail_(nullptr),      // Устанавливаем указатель на хвост списка как nullptr (пустой список)
      size_node_(nullptr)  // Инициализируем указатель на специальный узел `size_node_` как nullptr
{
  // Создаём специальный узел `size_node_`, который будет хранить информацию о размере списка.
  // При создании узла в него сразу передаётся начальное значение размера списка (0).
  size_node_ = new node(size_);
  
  // Настраиваем связи специального узла `size_node_` с головой и хвостом списка.
  set_size_node();
}

// Конструктор класса list
// Данный конструктор создаёт список с заданным количеством элементов `n`.
// Каждый из элементов списка инициализируется значением `0`.
// Конструктор также создаёт специальный узел `size_node_`, который хранит информацию о размере списка.

template <typename T>
list<T>::list(size_type n)
    : size_(0),            // Инициализируем начальный размер списка как 0
      head_(nullptr),      // Устанавливаем указатель на голову списка как nullptr (список изначально пуст)
      tail_(nullptr),      // Устанавливаем указатель на хвост списка как nullptr
      size_node_(nullptr)  // Инициализируем указатель на специальный узел `size_node_` как nullptr
{
  // Проверяем, что размер списка `n` больше 0
  if (n <= 0) {
    throw length_error("size of list should be more than 0");  // Бросаем исключение, если `n` <= 0
  }

  // Создаём специальный узел `size_node_`, который будет хранить информацию о размере списка
  size_node_ = new node(size_);

  // Заполняем список `n` элементами, каждый из которых равен `0`
  for (size_type i = 0; i < n; i++) {
    push_back(0);  // Добавляем элемент в конец списка
  }

  // Настраиваем связи для узла `size_node_`
  set_size_node();
}
// Конструктор класса list
// Данный конструктор создаёт список на основе инициализирующего списка `items`.
// Инициализирующий список позволяет создать контейнер с заранее заданными значениями.
// Конструктор также создаёт специальный узел `size_node_`, который хранит информацию о размере списка.

template <typename T>
list<T>::list(std::initializer_list<value_type> const& items)
    : size_(0),            // Инициализируем размер списка как 0
      head_(nullptr),      // Устанавливаем указатель на голову списка как nullptr (список пуст)
      tail_(nullptr),      // Устанавливаем указатель на хвост списка как nullptr
      size_node_(nullptr)  // Инициализируем указатель на специальный узел `size_node_` как nullptr
{
  // Проверяем, что размер инициализирующего списка корректен
  if (items.size() < 0) {
    throw length_error("size of list should be more than 0");  // Бросаем исключение, если размер некорректен
  }

  // Создаём специальный узел `size_node_`, который будет хранить информацию о размере списка
  size_node_ = new node(size_);

  // Проходим по всем элементам инициализирующего списка `items`
  for (const_reference i : items) {
    push_back(i);  // Добавляем каждый элемент в конец списка
  }

  // Настраиваем связи для узла `size_node_`
  set_size_node();
}

// Конструктор копирования класса list
// Этот конструктор создаёт новый список как копию другого списка `l`.
// Все элементы исходного списка `l` копируются в новый список.
// Связи между узлами сохраняются, однако создаются новые объекты для узлов.

template <typename T>
list<T>::list(const list& l)
    : size_(0),            // Инициализируем размер нового списка как 0
      head_(nullptr),      // Устанавливаем указатель на голову нового списка как nullptr
      tail_(nullptr),      // Устанавливаем указатель на хвост нового списка как nullptr
      size_node_(nullptr)  // Инициализируем указатель на специальный узел `size_node_` как nullptr
{
  // Создаём временный указатель для итерации по узлам исходного списка
  node* l_curr_node = l.head_;

  // Проходим по каждому узлу исходного списка
  for (size_type i = 0; i < l.size_; i++) {
    push_back(l_curr_node->value_);  // Добавляем значение текущего узла в конец нового списка
    l_curr_node = l_curr_node->next_;  // Переходим к следующему узлу в исходном списке
  }

  // Примечание: Узел size_node_ не создаётся в данном коде.
  // Если узел size_node_ нужен, его создание и настройка должны быть добавлены.
}

// Конструктор перемещения класса list
// Этот конструктор переносит содержимое списка `l` в новый список, оставляя `l` в пустом состоянии.
// Это позволяет избежать лишнего копирования данных и повысить производительность.

template <typename T>
list<T>::list(list&& l)
    : size_(0),            // Инициализируем размер нового списка как 0
      head_(nullptr),      // Устанавливаем указатель на голову нового списка как nullptr
      tail_(nullptr),      // Устанавливаем указатель на хвост нового списка как nullptr
      size_node_(nullptr)  // Инициализируем указатель на специальный узел `size_node_` как nullptr
{
  // Указатель для итерации по узлам списка `l`
  node* l_curr_node = l.head_;

  // Удаляем все существующие элементы в текущем (новом) списке, если таковые имеются
  clear();

  // Переносим все узлы из списка `l` в текущий список
  for (size_type i = 0; i < l.size_; i++) {
    push_back(l_curr_node->value_);  // Добавляем значение текущего узла в конец нового списка
    l_curr_node = l_curr_node->next_;  // Переходим к следующему узлу в списке `l`
  }

  // Обнуляем данные в списке `l`, так как он теперь перемещён
  l.size_ = 0;
  l.head_ = l.tail_ = nullptr;
}

// Деструктор класса list
// Освобождает ресурсы, связанные с экземпляром списка, включая все его узлы
// и специальный узел `size_node_`.

template <typename T>
list<T>::~list() {
  // Удаляем все элементы списка, освобождая динамически выделенную память для каждого узла.
  clear();

  // Удаляем специальный узел `size_node_`, который хранит информацию о размере списка.
  delete size_node_;
}

// Перегрузка оператора перемещающего присваивания для класса list.
// Позволяет переместить содержимое одного списка в другой с минимальными затратами ресурсов.
//
// Параметры:
// - l: R-value ссылка на список, содержимое которого будет перемещено.
//
// Возвращает:
// - Ссылку на текущий объект (*this) для обеспечения цепочки вызовов.
template <typename T>
list<T>& list<T>::operator=(list&& l) {
  // Удаляем текущие элементы списка, чтобы освободить память и подготовить объект к переносу новых данных.
  while (!empty()) {
    pop_back();
  }

  // Инициализируем временный указатель на голову перемещаемого списка.
  node* l_curr_node = l.head_;

  // Перемещаем элементы из списка `l` в текущий список.
  for (size_type i = 0; i < l.size_; i++) {
    push_back(l_curr_node->value_);
    l_curr_node = l_curr_node->next_;
  }

  // Возвращаем текущий объект для поддержки цепочки вызовов.
  return *this;
}


// Возвращает значение первого элемента списка.
// Предполагается, что список не пуст, поэтому доступ осуществляется напрямую через head_.
// Если список пуст, поведение неопределено.
template <typename T>
typename list<T>::const_reference list<T>::front() {
  return head_->value_;  // Возвращаем значение узла, на который указывает head_.
}

// Возвращает значение последнего элемента списка.
// Аналогично front(), предполагается, что список не пуст.
template <typename T>
typename list<T>::const_reference list<T>::back() {
  return tail_->value_;  // Возвращаем значение узла, на который указывает tail_.
}

// Возвращает итератор, указывающий на первый элемент списка.
// Если список пуст, возвращается итератор, указывающий на size_node_ (служебный узел).
template <typename T>
typename list<T>::iterator list<T>::begin() {
  return head_ ? iterator(head_) : iterator(size_node_);  // Итератор на head_ или size_node_.
}

// Возвращает итератор, указывающий на конец списка (size_node_).
// Итератор end() используется для обозначения границы за последним элементом.
template <typename T>
typename list<T>::iterator list<T>::end() {
  return iterator(size_node_);  // Итератор на служебный узел size_node_.
}

// Проверяет, пуст ли список.
// Возвращает true, если head_ равен nullptr (нет элементов в списке).
template <typename T>
bool list<T>::empty() {
  return (this->head_ == nullptr);  // Список пуст, если нет указателя на первый элемент.
}

// Возвращает количество элементов в списке.
// Значение хранится в переменной size_ и поддерживается актуальным.
template <typename T>
typename list<T>::size_type list<T>::size() {
  return size_;  // Возвращаем количество узлов.
}

// Возвращает максимально возможное количество элементов в списке.
// Значение основано на максимально возможном размере типа size_type и размере узла.
template <typename T>
typename list<T>::size_type list<T>::max_size() {
  return numeric_limits<size_type>::max() / sizeof(node);  // Рассчитываем максимум по памяти.
}


// Очищает список, удаляя все элементы поочередно с конца.
// Каждый элемент списка удаляется с помощью метода pop_back, пока список не станет пустым.
template <typename T>
void list<T>::clear() {
  // Пока список не пустой, удаляем элементы с конца.
  while (!empty()) {
    pop_back();  // Удаляем последний элемент с помощью pop_back.
  }
}


// Возвращает указатель на узел списка, находящийся на позиции index.
// Если индекс выходит за пределы списка, возвращает указатель на nullptr.
// Важно, что индексация начинается с 0.
template <typename T>
typename list<T>::node* list<T>::get_at(list<T>::value_type index) {
  node* temp = head_;  // Начинаем с первого узла (head_).
  value_type temp_node_index = 0;  // Индекс текущего узла, начинаем с 0.

  // Проверяем, что список не пуст (head_ != nullptr).
  if (temp != nullptr) {
    // Перебираем узлы, двигаясь по списку от начала до нужного индекса.
    while (temp_node_index != index) {
      temp = temp->next_;  // Переходим к следующему узлу.
      temp_node_index++;   // Увеличиваем индекс.
      
      // Если следующий узел не существует, значит, индекс выходит за пределы.
      if (temp == nullptr) {
        return nullptr;  // Возвращаем nullptr, если индекс за пределами списка.
      }
    }
  }
  // Возвращаем указатель на найденный узел (или nullptr, если индекс не найден).
  return temp;
}


// Оператор индексирования ([]) для доступа к узлам списка по индексу.
// Использует метод get_at для получения узла по указанному индексу.
// Возвращает указатель на узел с данным индексом (или nullptr, если индекс выходит за пределы).
template <typename T>
typename list<T>::node* list<T>::operator[](list<T>::value_type index) {
  // Внутри оператора используется метод get_at для получения узла.
  return get_at(index);  // Возвращаем указатель на узел с данным индексом.
}


// Вставляет новый узел со значением value перед позицией pos в список.
// Возвращает итератор на вставленный узел.
template <typename T>
typename list<T>::iterator list<T>::insert(list<T>::iterator pos,
                                           list<T>::const_reference value) {
  // Создаем новый узел со значением value.
  node* new_node = new node(value);

  // Указатели на текущий узел (pos.ptr_) и его предыдущий узел.
  node* current = pos.ptr_;
  node* prev = current->prev_;

  // Если список пустой, новый узел становится и головой, и хвостом.
  if (empty()) {
    new_node->next_ = size_node_;  // Следующий узел будет size_node_ (псевдо-узел).
    new_node->prev_ = size_node_;  // Предыдущий узел тоже будет size_node_.
    head_ = new_node;  // Новый узел становится головой списка.
    tail_ = new_node;  // Новый узел становится хвостом списка.
  } else {
    // Если текущий узел - это голова списка, новый узел становится головой.
    if (current == head_) {
      head_ = new_node;
    }
    // Если текущий узел - это псевдо-узел size_node_, новый узел становится хвостом.
    else if (current == size_node_) {
      tail_ = new_node;
    }

    // Обновляем указатели соседних узлов:
    // Предыдущий узел теперь указывает на новый узел.
    prev->next_ = new_node;

    // Новый узел ссылается на предыдущий узел.
    new_node->prev_ = prev;

    // Новый узел ссылается на текущий узел.
    new_node->next_ = current;

    // Текущий узел ссылается на новый узел.
    current->prev_ = new_node;
  }

  // Увеличиваем размер списка.
  size_++;

  // Обновляем псевдо-узел size_node_, который хранит размер списка.
  set_size_node();

  // Возвращаем итератор на только что вставленный узел.
  return iterator(new_node);
}


// Удаляет элемент, на который указывает итератор pos, из списка.
// Выбрасывает исключение, если передан неверный итератор (например, на конец списка).
template <typename T>
void list<T>::erase(list<T>::iterator pos) {
  // Получаем указатель на узел, на который указывает итератор pos.
  node* current = pos.ptr_;

  // Проверка на пустоту списка или на попытку удалить узел, который не существует (size_node_).
  if (empty() || current == size_node_) {
    throw invalid_argument("invalid argument");
  }

  // Если удаляемый узел - это голова списка.
  if (current == head_) {
    // Если следующий узел существует (не является size_node_), обновляем голову списка.
    if (current->next_ != size_node_ && current->next_) {
      head_ = current->next_;
    } else {
      // Если следующий узел не существует, то голова списка становится псевдо-узел size_node_.
      head_ = size_node_;
    }
  } 
  // Если удаляемый узел - это хвост списка.
  else if (current == tail_) {
    // Если предыдущий узел существует (не является size_node_), обновляем хвост списка.
    if (current->prev_ != size_node_ && current->prev_) {
      tail_ = current->prev_;
    } else {
      // Если предыдущий узел не существует, хвост становится псевдо-узел size_node_.
      tail_ = size_node_;
    }
  }

  // Обновляем ссылки на следующий и предыдущий узлы для окружающих элементов.
  current->prev_->next_ = current->next_; // Предыдущий узел теперь ссылается на следующий.
  current->next_->prev_ = current->prev_; // Следующий узел теперь ссылается на предыдущий.

  // Удаляем текущий узел.
  delete current;

  // Уменьшаем размер списка на 1.
  size_--;

  // Обновляем размер списка в псевдо-узле size_node_.
  set_size_node();
}

template <typename T>
void list<T>::push_back(list<T>::const_reference value) {
  // Создаем новый узел с переданным значением value.
  node* new_tail = new node(value);

  // Проверка, является ли список пустым.
  if (empty()) {
    // Если список пуст, новый узел становится и головой, и хвостом списка.
    head_ = new_tail;
    tail_ = new_tail;
  } else {
    // Если список не пуст, вставляем новый узел в конец списка.
    new_tail->prev_ = tail_;        // Новый узел ссылается на текущий хвост.
    tail_->next_ = new_tail;        // Текущий хвост ссылается на новый узел.
    tail_ = new_tail;               // Обновляем хвост списка на новый узел.
  }

  // Увеличиваем размер списка.
  size_++;
};

template <typename T>
void list<T>::pop_back() {
  // Проверка, является ли список пустым.
  if (empty()) {
    // Если список пуст, выбрасываем исключение, так как удаление элемента невозможно.
    throw length_error("list is empty");
  }

  // Сохраняем указатель на последний узел (хвост списка).
  node* last_node = tail_;

  // Проверяем, если в списке только один элемент.
  if (size_ == 1) {
    // Если в списке только один элемент, то после удаления списка голова и хвост должны стать nullptr.
    head_ = nullptr;
    tail_ = nullptr;
  } else {
    // Если в списке более одного элемента, обновляем хвост на предыдущий элемент.
    tail_ = last_node->prev_;
    tail_->next_ = nullptr;  // Устанавливаем указатель next_ у нового хвоста в nullptr, так как это последний элемент.
  }

  // Освобождаем память, занятую последним узлом.
  delete last_node;

  // Уменьшаем размер списка.
  size_--;
}

template <typename T>
void list<T>::pop_back() {
  // Проверка, является ли список пустым.
  if (empty()) {
    // Если список пуст, выбрасываем исключение, так как удаление элемента невозможно.
    throw length_error("list is empty");
  }

  // Сохраняем указатель на последний узел (хвост списка).
  node* last_node = tail_;

  // Проверяем, если в списке только один элемент.
  if (size_ == 1) {
    // Если в списке только один элемент, то после удаления списка голова и хвост должны стать nullptr.
    head_ = nullptr;
    tail_ = nullptr;
  } else {
    // Если в списке более одного элемента, обновляем хвост на предыдущий элемент.
    tail_ = last_node->prev_;
    tail_->next_ = nullptr;  // Устанавливаем указатель next_ у нового хвоста в nullptr, так как это последний элемент.
  }

  // Освобождаем память, занятую последним узлом.
  delete last_node;

  // Уменьшаем размер списка.
  size_--;
}


template <typename T>
void list<T>::push_front(list<T>::const_reference value) {
  // Создаем новый узел с переданным значением.
  node* new_head = new node(value);

  // Если список пуст, новый элемент станет и головой, и хвостом списка.
  if (empty()) {
    head_ = new_head;  // Новый элемент становится головой.
    tail_ = new_head;  // Новый элемент также становится хвостом.
  }

  // Если список не пуст, то вставляем новый элемент в начало списка.
  new_head->next_ = head_;  // Новый элемент указывает на текущую голову.
  head_->prev_ = new_head;  // Старая голова теперь ссылается на новый элемент.
  head_ = new_head;         // Новый элемент становится новой головой списка.

  // Увеличиваем размер списка.
  size_++;
}


template <typename T>
void list<T>::swap(list<T>& other) {
  // Обмениваем указатели на голову списков.
  std::swap(head_, other.head_);
  
  // Обмениваем указатели на хвост списков.
  std::swap(tail_, other.tail_);
  
  // Обмениваем размеры списков.
  std::swap(size_, other.size_);
  
  // Обмениваем указатели на size_node_ (если есть).
  std::swap(size_node_, other.size_node_);
}


template <typename T>
void list<T>::merge(list<T>& other) {
  // Проверяем, что второй список не пуст.
  if (!other.empty()) {
    
    // Создаем итераторы для обоих списков.
    iterator this_iterator = this->begin();
    iterator other_iterator = other.begin();
    
    // Итерируем по текущему списку (this), пока не дойдем до конца.
    while (this_iterator != this->end()) {
      // Если есть еще элементы во втором списке (other), продолжаем объединение.
      if (other_iterator != other.end()) {
        // Если текущий элемент из списка this больше или равен текущему элементу из списка other,
        // вставляем элемент из списка other в текущий список (this).
        if (this_iterator.ptr_->value_ >= other_iterator.ptr_->value_) {
          this->insert(this_iterator, other_iterator.ptr_->value_);
          // Переходим к следующему элементу во втором списке (other).
          other_iterator++;
        } else {
          // Если элемент из списка this меньше элемента из списка other, переходим к следующему элементу в списке this.
          this_iterator++;
        }
      }
    }
    
    // После того как все элементы второго списка были вставлены в первый,
    // вставляем оставшиеся элементы второго списка (если они есть) в конец.
    while (other_iterator != other.end()) {
      this->insert(this_iterator, other_iterator.ptr_->value_);
      other_iterator++;
    }
    
    // Очищаем второй список, так как все его элементы были перенесены в первый.
    other.clear();
  }
};

template <typename T>
void list<T>::splice(list<T>::const_iterator pos, list<T>& other) {
  // Проверяем, что второй список не пуст.
  if (!other.empty()) {
    // Проходим по всем элементам второго списка.
    for (iterator i = other.begin(); i != other.end(); i++) {
      // Вставляем каждый элемент из второго списка в первый.
      this->insert(pos, *i);
    }
  }
  // Очищаем второй список после переноса всех его элементов в первый.
  other.clear();
}


template <typename T>
void list<T>::reverse() {
  // Проверка, что список не пуст
  if (!this->empty()) {
    // Инициализация указателей
    node* current = head_;  // Указатель на текущий элемент
    node* prev = NULL;      // Указатель на предыдущий элемент (вначале NULL)
    node* next = NULL;      // Указатель на следующий элемент (для временного хранения)

    // Проход по списку с разворотом направлений указателей
    while (current != size_node_) {  // Пока не достигнем конца списка
      next = current->next_;  // Сохраняем следующий элемент
      current->next_ = prev;  // Меняем направление: текущий элемент теперь указывает на предыдущий
      prev = current;         // Перемещаем указатель prev на текущий элемент
      current = next;         // Переходим к следующему элементу
    }
    
    // Обновляем head_ на последний обработанный элемент (теперь это новый первый элемент)
    head_ = prev;
  }
}


template <typename T>
void list<T>::unique() {
  // Проверяем, что список не пуст
  if (!this->empty()) {
    // Итерируем по списку с помощью итератора
    for (iterator iter = this->begin(); iter != this->end(); iter++) {
      // Если текущий элемент равен предыдущему, значит, это дубликат
      if (iter.ptr_->value_ == iter.ptr_->prev_->value_) {
        // Удаляем предыдущий элемент, так как текущий и предыдущий одинаковы
        this->erase(iter - 1);
      }
    }
  }
}



template <typename T>
typename list<T>::node* list<T>::merge_nodes(list<T>::node* left_part,
                                             list<T>::node* right_part) {
  node* result = nullptr;

  // Если левая часть пустая, то возвращаем правую часть
  if (left_part == nullptr) {
    return right_part;
  } 
  // Если правая часть пустая, то возвращаем левую часть
  else if (right_part == nullptr) {
    return left_part;
  }

  // Сравниваем значения текущих узлов в обеих частях
  if (left_part->value_ > right_part->value_) {
    // Если значение в правой части меньше, то выбираем его
    result = right_part;
    // Рекурсивно вызываем merge_nodes для следующего элемента правой части и текущего элемента левой части
    result->next_ = merge_nodes(left_part, right_part->next_);
  } else {
    // Если значение в левой части меньше, то выбираем его
    result = left_part;
    // Рекурсивно вызываем merge_nodes для следующего элемента левой части и текущего элемента правой части
    result->next_ = merge_nodes(left_part->next_, right_part);
  }

  // Возвращаем результат слияния двух отсортированных частей
  return result;
}


template <typename value_type>
void list<value_type>::sort() {
  // Проверяем, что в списке больше одного элемента
  if (size_ > 1) {
    // Вызываем функцию быстрой сортировки, передавая итераторы на начало и конец списка
    quick_sort(begin(), --end());
  }
}


template <typename value_type>
void list<value_type>::quick_sort(iterator first, iterator last) {
  // Базовый случай: если итераторы равны, либо один из них указывает на пустое место (size_node_),
  // либо первый итератор равен последнему элементу (tail_), сортировка не требуется
  if (first == last || first == size_node_ || last == size_node_ || first == tail_) {
    return;
  }
  
  // Разделяем список на две части, используя опорный элемент
  iterator pivot = partition(first, last);
  
  // Рекурсивно сортируем левую часть списка
  quick_sort(first, --pivot);
  
  // Рекурсивно сортируем правую часть списка
  quick_sort(++pivot, last);
}


template <typename value_type>
typename list<value_type>::iterator list<value_type>::partition(iterator first,
                                                                iterator last) {
  // Сохраняем значение последнего элемента в качестве опорного (pivot)
  value_type pivot_value = last.ptr_->value_;
  
  // Инициализируем итератор i, который будет отслеживать границу подсписка с элементами, меньше или равные опорному
  iterator i = first;

  // Проходим по всем элементам от first до last (не включая last)
  for (iterator j = first; j != last; ++j) {
    // Если текущий элемент меньше или равен опорному, меняем его местами с элементом i и двигаем i дальше
    if (j.ptr_->value_ <= pivot_value) {
      std::swap(i.ptr_->value_, j.ptr_->value_);
      i++;  // Инкрементируем i, так как нашли элемент, который должен быть слева от опорного
    }
  }

  // В конце меняем местами элемент на позиции i с опорным элементом
  std::swap(i.ptr_->value_, last.ptr_->value_);

  // Возвращаем итератор, который теперь указывает на место, куда опорный элемент должен быть размещен
  return i;
}

// Конструктор по умолчанию для итератора
template <typename T>
list<T>::listIterator::listIterator() {}

// Конструктор итератора, принимающий указатель на узел списка
template <typename T>
list<T>::listIterator::listIterator(typename list<T>::node* ptr) : ptr_(ptr) {}

// Операция пре-инкремента (++iter) для итератора.
// Сдвигает указатель итератора на следующий элемент списка.
template <typename T>
typename list<T>::listIterator& list<T>::listIterator::operator++() {
  ptr_ = ptr_->next_;  // Переход к следующему элементу
  return *this;        // Возвращаем текущий итератор для цепочки операций
}

// Операция пост-инкремента (iter++) для итератора.
// Создает копию текущего итератора, сдвигает указатель на следующий элемент и возвращает копию.
template <typename T>
typename list<T>::listIterator list<T>::listIterator::operator++(int) {
  listIterator temp = *this;  // Создаем копию текущего итератора
  ++(*this);                  // Инкрементируем текущий итератор
  return temp;                 // Возвращаем прежний итератор (копию)
}

// Операция пре-декремента (--iter) для итератора.
// Сдвигает указатель итератора на предыдущий элемент списка.
template <typename T>
typename list<T>::listIterator& list<T>::listIterator::operator--() {
  ptr_ = ptr_->prev_;  // Переход к предыдущему элементу
  return *this;        // Возвращаем текущий итератор для цепочки операций
}

// Операция пост-декремента (iter--) для итератора.
// Создает копию текущего итератора, сдвигает указатель на предыдущий элемент и возвращает копию.
template <typename T>
typename list<T>::listIterator list<T>::listIterator::operator--(int) {
  listIterator temp = *this;  // Создаем копию текущего итератора
  --(*this);                  // Декрементируем текущий итератор
  return temp;                 // Возвращаем прежний итератор (копию)
}

template <typename T>
typename list<T>::listIterator list<T>::listIterator::operator-(
    list<T>::size_type value) {
  
  // Временная переменная temp, которая будет использоваться для навигации по списку
  node* temp = ptr_;
  
  // Цикл для перемещения итератора назад на 'value' позиций
  for (size_type i = 0; i < value; i++) {
    // Перемещение указателя temp на предыдущий узел
    temp = temp->prev_;
  }
  
  // Создание нового итератора result, который будет указывать на узел 'temp'
  listIterator result(temp);
  
  // Возврат нового итератора, который теперь указывает на позицию, сдвинутую на 'value' шагов назад
  return result;
}
// Оператор разыменовывания для итератора
template <typename T>
typename list<T>::value_type list<T>::listIterator::operator*() const {
  // Возвращаем значение, на которое указывает итератор, из поля value_ текущего узла
  return ptr_->value_;
}

// Оператор стрелки для итератора
template <typename T>
typename list<T>::value_type list<T>::listIterator::operator->() const {
  // Возвращаем указатель на значение узла, на который указывает итератор
  return &ptr_->value_;
}

// Оператор равенства для итераторов
template <typename T>
bool list<T>::listIterator::operator==(list<T>::listIterator other) {
  // Сравниваем указатели на узлы, на которые указывают два итератора
  return (this->ptr_ == other.ptr_);
}

// Оператор неравенства для итераторов
template <typename T>
bool list<T>::listIterator::operator!=(list<T>::listIterator other) {
  // Сравниваем указатели на узлы, на которые указывают два итератора
  return (this->ptr_ != other.ptr_);
}

// Конструктор для создания константного итератора из обычного итератора
template <typename T>
list<T>::listConstIterator::listConstIterator(listIterator other)
    : listIterator(other) {}  // Инициализируем базовый итератор обычным итератором

// Оператор разыменовывания для константного итератора
template <typename T>
typename list<T>::const_reference list<T>::listConstIterator::operator*() {
  // Вызываем оператор разыменовывания из базового итератора, но возвращаем константное значение
  return listIterator::operator*();
}

};  // namespace s21